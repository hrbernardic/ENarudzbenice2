/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAdreseClient {
  getAll(): Observable<Adresa[] | null>;
}

@Injectable()
export class AdreseClient implements IAdreseClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional()
    @Inject(API_BASE_URL)
    baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  getAll(): Observable<Adresa[] | null> {
    let url_ = this.baseUrl + '/api/Adrese';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<Adresa[] | null>>(<any>_observableThrow(e));
            }
          } else return <Observable<Adresa[] | null>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<Adresa[] | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200) result200.push(Adresa.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<Adresa[] | null>(<any>null);
  }
}

export interface IAuthClient {
  createUser(command: UserCreateCommand): Observable<FileResponse>;
  login(command: UserLoginCommand): Observable<LoginDto | null>;
}

@Injectable()
export class AuthClient implements IAuthClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional()
    @Inject(API_BASE_URL)
    baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  createUser(command: UserCreateCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Auth/CreateUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateUser(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateUser(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  login(command: UserLoginCommand): Observable<LoginDto | null> {
    let url_ = this.baseUrl + '/api/Auth/Login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin(<any>response_);
            } catch (e) {
              return <Observable<LoginDto | null>>(<any>_observableThrow(e));
            }
          } else return <Observable<LoginDto | null>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processLogin(response: HttpResponseBase): Observable<LoginDto | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? LoginDto.fromJS(resultData200) : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<LoginDto | null>(<any>null);
  }
}

export interface IDjelatnostiClient {
  query(
    pageNumber: number | undefined,
    pageSize: number | undefined,
    sortProperty: string | null | undefined,
    sortOrder: string | null | undefined
  ): Observable<QueryResultOfDjelatnost | null>;
  getAll(): Observable<Djelatnost[] | null>;
  create(request: Request): Observable<FileResponse>;
  get(id: string): Observable<FileResponse>;
  update(id: string, request: Request2): Observable<FileResponse>;
  delete(id: string): Observable<FileResponse>;
}

@Injectable()
export class DjelatnostiClient implements IDjelatnostiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional()
    @Inject(API_BASE_URL)
    baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  query(
    pageNumber: number | undefined,
    pageSize: number | undefined,
    sortProperty: string | null | undefined,
    sortOrder: string | null | undefined
  ): Observable<QueryResultOfDjelatnost | null> {
    let url_ = this.baseUrl + '/api/Djelatnosti/Query?';
    if (pageNumber === null) throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined) url_ += 'pageNumber=' + encodeURIComponent('' + pageNumber) + '&';
    if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'pageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (sortProperty !== undefined) url_ += 'sortProperty=' + encodeURIComponent('' + sortProperty) + '&';
    if (sortOrder !== undefined) url_ += 'sortOrder=' + encodeURIComponent('' + sortOrder) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processQuery(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processQuery(<any>response_);
            } catch (e) {
              return <Observable<QueryResultOfDjelatnost | null>>(<any>_observableThrow(e));
            }
          } else return <Observable<QueryResultOfDjelatnost | null>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processQuery(response: HttpResponseBase): Observable<QueryResultOfDjelatnost | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? QueryResultOfDjelatnost.fromJS(resultData200) : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<QueryResultOfDjelatnost | null>(<any>null);
  }

  getAll(): Observable<Djelatnost[] | null> {
    let url_ = this.baseUrl + '/api/Djelatnosti';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<Djelatnost[] | null>>(<any>_observableThrow(e));
            }
          } else return <Observable<Djelatnost[] | null>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<Djelatnost[] | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200) result200.push(Djelatnost.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<Djelatnost[] | null>(<any>null);
  }

  create(request: Request): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Djelatnosti';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  get(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Djelatnosti/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  update(id: string, request: Request2): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Djelatnosti/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  delete(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Djelatnosti/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }
}

export class BaseEntity implements IBaseEntity {
  id?: string;

  constructor(data?: IBaseEntity) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
    }
  }

  static fromJS(data: any): BaseEntity {
    data = typeof data === 'object' ? data : {};
    let result = new BaseEntity();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    return data;
  }
}

export interface IBaseEntity {
  id?: string;
}

export class SifarnikEntity extends BaseEntity implements ISifarnikEntity {
  naziv?: string | undefined;
  sifra?: number;

  constructor(data?: ISifarnikEntity) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.naziv = data['naziv'];
      this.sifra = data['sifra'];
    }
  }

  static fromJS(data: any): SifarnikEntity {
    data = typeof data === 'object' ? data : {};
    let result = new SifarnikEntity();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['naziv'] = this.naziv;
    data['sifra'] = this.sifra;
    super.toJSON(data);
    return data;
  }
}

export interface ISifarnikEntity extends IBaseEntity {
  naziv?: string | undefined;
  sifra?: number;
}

export class Adresa extends SifarnikEntity implements IAdresa {
  constructor(data?: IAdresa) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
    }
  }

  static fromJS(data: any): Adresa {
    data = typeof data === 'object' ? data : {};
    let result = new Adresa();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IAdresa extends ISifarnikEntity {}

export class UserCreateCommand implements IUserCreateCommand {
  email?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  naziv?: string | undefined;
  prezime?: string | undefined;

  constructor(data?: IUserCreateCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.email = data['email'];
      this.username = data['username'];
      this.password = data['password'];
      this.naziv = data['naziv'];
      this.prezime = data['prezime'];
    }
  }

  static fromJS(data: any): UserCreateCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UserCreateCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['username'] = this.username;
    data['password'] = this.password;
    data['naziv'] = this.naziv;
    data['prezime'] = this.prezime;
    return data;
  }
}

export interface IUserCreateCommand {
  email?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  naziv?: string | undefined;
  prezime?: string | undefined;
}

export class LoginDto implements ILoginDto {
  username?: string | undefined;
  displayName?: string | undefined;
  token?: string | undefined;

  constructor(data?: ILoginDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.username = data['username'];
      this.displayName = data['displayName'];
      this.token = data['token'];
    }
  }

  static fromJS(data: any): LoginDto {
    data = typeof data === 'object' ? data : {};
    let result = new LoginDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['displayName'] = this.displayName;
    data['token'] = this.token;
    return data;
  }
}

export interface ILoginDto {
  username?: string | undefined;
  displayName?: string | undefined;
  token?: string | undefined;
}

export class UserLoginCommand implements IUserLoginCommand {
  username?: string | undefined;
  password?: string | undefined;

  constructor(data?: IUserLoginCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.username = data['username'];
      this.password = data['password'];
    }
  }

  static fromJS(data: any): UserLoginCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UserLoginCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['password'] = this.password;
    return data;
  }
}

export interface IUserLoginCommand {
  username?: string | undefined;
  password?: string | undefined;
}

export class QueryParametersBase implements IQueryParametersBase {
  pageIndex?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;

  constructor(data?: IQueryParametersBase) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.pageIndex = data['pageIndex'];
      this.pageCount = data['pageCount'];
      this.pageSize = data['pageSize'];
      this.rowCount = data['rowCount'];
    }
  }

  static fromJS(data: any): QueryParametersBase {
    data = typeof data === 'object' ? data : {};
    let result = new QueryParametersBase();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageCount'] = this.pageCount;
    data['pageSize'] = this.pageSize;
    data['rowCount'] = this.rowCount;
    return data;
  }
}

export interface IQueryParametersBase {
  pageIndex?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
}

export class QueryResultOfDjelatnost extends QueryParametersBase implements IQueryResultOfDjelatnost {
  results?: Djelatnost[] | undefined;

  constructor(data?: IQueryResultOfDjelatnost) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      if (data['results'] && data['results'].constructor === Array) {
        this.results = [];
        for (let item of data['results']) this.results.push(Djelatnost.fromJS(item));
      }
    }
  }

  static fromJS(data: any): QueryResultOfDjelatnost {
    data = typeof data === 'object' ? data : {};
    let result = new QueryResultOfDjelatnost();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.results && this.results.constructor === Array) {
      data['results'] = [];
      for (let item of this.results) data['results'].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IQueryResultOfDjelatnost extends IQueryParametersBase {
  results?: Djelatnost[] | undefined;
}

export class Djelatnost extends SifarnikEntity implements IDjelatnost {
  radnik?: User | undefined;

  constructor(data?: IDjelatnost) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.radnik = data['radnik'] ? User.fromJS(data['radnik']) : <any>undefined;
    }
  }

  static fromJS(data: any): Djelatnost {
    data = typeof data === 'object' ? data : {};
    let result = new Djelatnost();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['radnik'] = this.radnik ? this.radnik.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface IDjelatnost extends ISifarnikEntity {
  radnik?: User | undefined;
}

export class IdentityUserOfGuid implements IIdentityUserOfGuid {
  id?: string;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;

  constructor(data?: IIdentityUserOfGuid) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.userName = data['userName'];
      this.normalizedUserName = data['normalizedUserName'];
      this.email = data['email'];
      this.normalizedEmail = data['normalizedEmail'];
      this.emailConfirmed = data['emailConfirmed'];
      this.passwordHash = data['passwordHash'];
      this.securityStamp = data['securityStamp'];
      this.concurrencyStamp = data['concurrencyStamp'];
      this.phoneNumber = data['phoneNumber'];
      this.phoneNumberConfirmed = data['phoneNumberConfirmed'];
      this.twoFactorEnabled = data['twoFactorEnabled'];
      this.lockoutEnd = data['lockoutEnd'] ? new Date(data['lockoutEnd'].toString()) : <any>undefined;
      this.lockoutEnabled = data['lockoutEnabled'];
      this.accessFailedCount = data['accessFailedCount'];
    }
  }

  static fromJS(data: any): IdentityUserOfGuid {
    data = typeof data === 'object' ? data : {};
    let result = new IdentityUserOfGuid();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['normalizedUserName'] = this.normalizedUserName;
    data['email'] = this.email;
    data['normalizedEmail'] = this.normalizedEmail;
    data['emailConfirmed'] = this.emailConfirmed;
    data['passwordHash'] = this.passwordHash;
    data['securityStamp'] = this.securityStamp;
    data['concurrencyStamp'] = this.concurrencyStamp;
    data['phoneNumber'] = this.phoneNumber;
    data['phoneNumberConfirmed'] = this.phoneNumberConfirmed;
    data['twoFactorEnabled'] = this.twoFactorEnabled;
    data['lockoutEnd'] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
    data['lockoutEnabled'] = this.lockoutEnabled;
    data['accessFailedCount'] = this.accessFailedCount;
    return data;
  }
}

export interface IIdentityUserOfGuid {
  id?: string;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
}

export class User extends IdentityUserOfGuid implements IUser {
  ime?: string | undefined;
  prezime?: string | undefined;
  aktivan?: boolean;
  datumIzmjene?: Date;
  datumIzrade?: Date;
  prikazIme?: string | undefined;
  tim?: Tim | undefined;

  constructor(data?: IUser) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.ime = data['ime'];
      this.prezime = data['prezime'];
      this.aktivan = data['aktivan'];
      this.datumIzmjene = data['datumIzmjene'] ? new Date(data['datumIzmjene'].toString()) : <any>undefined;
      this.datumIzrade = data['datumIzrade'] ? new Date(data['datumIzrade'].toString()) : <any>undefined;
      this.prikazIme = data['prikazIme'];
      this.tim = data['tim'] ? Tim.fromJS(data['tim']) : <any>undefined;
    }
  }

  static fromJS(data: any): User {
    data = typeof data === 'object' ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['ime'] = this.ime;
    data['prezime'] = this.prezime;
    data['aktivan'] = this.aktivan;
    data['datumIzmjene'] = this.datumIzmjene ? this.datumIzmjene.toISOString() : <any>undefined;
    data['datumIzrade'] = this.datumIzrade ? this.datumIzrade.toISOString() : <any>undefined;
    data['prikazIme'] = this.prikazIme;
    data['tim'] = this.tim ? this.tim.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface IUser extends IIdentityUserOfGuid {
  ime?: string | undefined;
  prezime?: string | undefined;
  aktivan?: boolean;
  datumIzmjene?: Date;
  datumIzrade?: Date;
  prikazIme?: string | undefined;
  tim?: Tim | undefined;
}

export class Tim extends SifarnikEntity implements ITim {
  radnoVrijeme?: string | undefined;
  kontaktBroj?: string | undefined;
  email?: string | undefined;
  godisnji?: string | undefined;
  aktivan?: boolean;
  adresaDostava?: string | undefined;
  adresa?: Adresa | undefined;
  djelatnost?: Djelatnost | undefined;

  constructor(data?: ITim) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.radnoVrijeme = data['radnoVrijeme'];
      this.kontaktBroj = data['kontaktBroj'];
      this.email = data['email'];
      this.godisnji = data['godisnji'];
      this.aktivan = data['aktivan'];
      this.adresaDostava = data['adresaDostava'];
      this.adresa = data['adresa'] ? Adresa.fromJS(data['adresa']) : <any>undefined;
      this.djelatnost = data['djelatnost'] ? Djelatnost.fromJS(data['djelatnost']) : <any>undefined;
    }
  }

  static fromJS(data: any): Tim {
    data = typeof data === 'object' ? data : {};
    let result = new Tim();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['radnoVrijeme'] = this.radnoVrijeme;
    data['kontaktBroj'] = this.kontaktBroj;
    data['email'] = this.email;
    data['godisnji'] = this.godisnji;
    data['aktivan'] = this.aktivan;
    data['adresaDostava'] = this.adresaDostava;
    data['adresa'] = this.adresa ? this.adresa.toJSON() : <any>undefined;
    data['djelatnost'] = this.djelatnost ? this.djelatnost.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface ITim extends ISifarnikEntity {
  radnoVrijeme?: string | undefined;
  kontaktBroj?: string | undefined;
  email?: string | undefined;
  godisnji?: string | undefined;
  aktivan?: boolean;
  adresaDostava?: string | undefined;
  adresa?: Adresa | undefined;
  djelatnost?: Djelatnost | undefined;
}

export class Request implements IRequest {
  naziv?: string | undefined;

  constructor(data?: IRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.naziv = data['naziv'];
    }
  }

  static fromJS(data: any): Request {
    data = typeof data === 'object' ? data : {};
    let result = new Request();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['naziv'] = this.naziv;
    return data;
  }
}

export interface IRequest {
  naziv?: string | undefined;
}

export class Request2 implements IRequest2 {
  id?: string;
  name?: string | undefined;

  constructor(data?: IRequest2) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
    }
  }

  static fromJS(data: any): Request2 {
    data = typeof data === 'object' ? data : {};
    let result = new Request2();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IRequest2 {
  id?: string;
  name?: string | undefined;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isSwaggerException = true;

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = function() {
        observer.next(this.result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
